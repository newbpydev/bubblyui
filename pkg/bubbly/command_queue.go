package bubbly

import (
	"sync"
	"time"

	tea "github.com/charmbracelet/bubbletea"
)

// CommandGenerator creates Bubbletea commands from reactive state changes.
//
// This interface defines how state changes are converted into tea.Cmd that
// trigger UI updates. Implementations can customize command generation behavior
// for different use cases (e.g., batching, throttling, custom messages).
//
// The automatic reactive bridge uses this to generate commands when Ref.Set()
// is called, eliminating manual event emission.
//
// Example:
//
//	type MyGenerator struct{}
//
//	func (g *MyGenerator) Generate(componentID, refID string, oldValue, newValue interface{}) tea.Cmd {
//	    return func() tea.Msg {
//	        return StateChangedMsg{
//	            ComponentID: componentID,
//	            RefID:       refID,
//	            OldValue:    oldValue,
//	            NewValue:    newValue,
//	            Timestamp:   time.Now(),
//	        }
//	    }
//	}
type CommandGenerator interface {
	// Generate creates a tea.Cmd from a state change.
	//
	// Parameters:
	//   - componentID: Unique identifier of the component owning the ref
	//   - refID: Unique identifier of the ref that changed
	//   - oldValue: Previous value before the change
	//   - newValue: New value after the change
	//
	// Returns a tea.Cmd that will be executed by Bubbletea's runtime.
	// The command typically returns a StateChangedMsg to trigger UI updates.
	Generate(componentID, refID string, oldValue, newValue interface{}) tea.Cmd
}

// StateChangedMsg signals that a reactive state value has changed.
//
// This message is generated automatically by CommandRef when Set() is called
// and is processed by the component's Update() method to trigger lifecycle
// hooks and re-rendering.
//
// The message contains metadata about the change for debugging and tracking:
//   - ComponentID: Which component owns the changed ref
//   - RefID: Which ref changed
//   - OldValue: Value before the change
//   - NewValue: Value after the change
//   - Timestamp: When the change occurred
//
// Example:
//
//	func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
//	    switch msg := msg.(type) {
//	    case StateChangedMsg:
//	        // State already updated synchronously
//	        // This message triggers lifecycle hooks and re-render
//	        if msg.ComponentID == m.component.ID() {
//	            // Component will execute onUpdated hooks
//	        }
//	    }
//	    return m, nil
//	}
type StateChangedMsg struct {
	ComponentID string
	RefID       string
	OldValue    interface{}
	NewValue    interface{}
	Timestamp   time.Time
}

// CommandQueue is a thread-safe queue for pending Bubbletea commands.
//
// This queue stores commands generated by CommandRef.Set() operations and
// provides them to the component's Update() method for batching and execution.
//
// Thread Safety:
//
// All methods are thread-safe and can be called concurrently from multiple
// goroutines. A mutex protects the internal command slice.
//
// Example:
//
//	queue := NewCommandQueue()
//	queue.Enqueue(cmd1)
//	queue.Enqueue(cmd2)
//
//	// In component's Update():
//	cmds := queue.DrainAll()  // Returns [cmd1, cmd2] and clears queue
type CommandQueue struct {
	commands []tea.Cmd
	mu       sync.Mutex
}

// NewCommandQueue creates a new empty command queue.
func NewCommandQueue() *CommandQueue {
	return &CommandQueue{
		commands: make([]tea.Cmd, 0, 8), // Pre-allocate for common case
	}
}

// Enqueue adds a command to the queue.
//
// This method is thread-safe and can be called concurrently.
// Nil commands are ignored.
//
// Example:
//
//	queue.Enqueue(cmd)
func (cq *CommandQueue) Enqueue(cmd tea.Cmd) {
	if cmd == nil {
		return
	}

	cq.mu.Lock()
	defer cq.mu.Unlock()
	cq.commands = append(cq.commands, cmd)
}

// DrainAll returns all queued commands and clears the queue.
//
// This method is thread-safe and can be called concurrently.
// Returns an empty slice if the queue is empty.
//
// Example:
//
//	cmds := queue.DrainAll()
//	for _, cmd := range cmds {
//	    // Execute command
//	}
func (cq *CommandQueue) DrainAll() []tea.Cmd {
	cq.mu.Lock()
	defer cq.mu.Unlock()

	if len(cq.commands) == 0 {
		return nil
	}

	cmds := cq.commands
	cq.commands = make([]tea.Cmd, 0, 8)
	return cmds
}

// Len returns the number of commands currently in the queue.
//
// This method is thread-safe and can be called concurrently.
//
// Example:
//
//	count := queue.Len()
func (cq *CommandQueue) Len() int {
	cq.mu.Lock()
	defer cq.mu.Unlock()
	return len(cq.commands)
}

// Clear removes all commands from the queue.
//
// This method is thread-safe and can be called concurrently.
//
// Example:
//
//	queue.Clear()
func (cq *CommandQueue) Clear() {
	cq.mu.Lock()
	defer cq.mu.Unlock()
	cq.commands = make([]tea.Cmd, 0, 8)
}

// Peek returns a snapshot of all commands in the queue without removing them.
//
// This method is primarily used for debugging and inspection purposes.
// It returns a copy of the command slice, so modifications to the returned
// slice do not affect the queue.
//
// Thread Safety:
//
// This method is thread-safe and can be called concurrently. However, the
// returned slice is a snapshot at the time of the call. Concurrent modifications
// to the queue may result in the snapshot being stale.
//
// Example:
//
//	commands := queue.Peek()
//	for _, cmd := range commands {
//	    // Inspect command without modifying queue
//	}
//
// Returns:
//   - []tea.Cmd: Copy of commands currently in the queue
//   - nil if queue is empty
func (cq *CommandQueue) Peek() []tea.Cmd {
	cq.mu.Lock()
	defer cq.mu.Unlock()

	if len(cq.commands) == 0 {
		return nil
	}

	// Return a copy to prevent external modification
	commands := make([]tea.Cmd, len(cq.commands))
	copy(commands, cq.commands)
	return commands
}

// defaultCommandGenerator is the internal default implementation of CommandGenerator.
// It is unexported and used as the default generator for components.
// For public API, use commands.DefaultCommandGenerator from the commands package.
type defaultCommandGenerator struct{}

// Generate creates a tea.Cmd that returns a StateChangedMsg when executed.
func (g *defaultCommandGenerator) Generate(
	componentID, refID string,
	oldValue, newValue interface{},
) tea.Cmd {
	return func() tea.Msg {
		return StateChangedMsg{
			ComponentID: componentID,
			RefID:       refID,
			OldValue:    oldValue,
			NewValue:    newValue,
			Timestamp:   time.Now(),
		}
	}
}
