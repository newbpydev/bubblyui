package testutil

import (
	tea "github.com/charmbracelet/bubbletea"

	"github.com/newbpydev/bubblyui/pkg/bubbly"
)

// KeyBindingsTester provides utilities for testing key binding registration and help text generation.
//
// It wraps a component and provides methods for simulating key presses, verifying help text,
// and detecting key binding conflicts. This is useful for testing that keyboard shortcuts
// work correctly and that help text is generated properly.
//
// Type Safety:
//   - Thread-safe access to key bindings
//   - Clear assertion methods for help text verification
//   - Conflict detection for duplicate key bindings
//
// Example:
//
//	func TestKeyBindings(t *testing.T) {
//		comp, _ := bubbly.NewComponent("Counter").
//			WithKeyBinding(" ", "increment", "Increment counter").
//			WithKeyBinding("r", "reset", "Reset counter").
//			Setup(func(ctx *bubbly.Context) {
//				count := ctx.Ref(0)
//				ctx.On("increment", func(_ interface{}) {
//					count.Set(count.Get().(int) + 1)
//				})
//			}).
//			Template(func(ctx bubbly.RenderContext) string {
//				return "Counter"
//			}).
//			Build()
//
//		tester := testutil.NewKeyBindingsTester(comp)
//
//		// Simulate key press
//		tester.SimulateKeyPress(" ")
//
//		// Verify help text
//		tester.AssertHelpText(t, " : Increment counter • r: Reset counter")
//
//		// Detect conflicts
//		conflicts := tester.DetectConflicts()
//		assert.Empty(t, conflicts)
//	}
type KeyBindingsTester struct {
	// component is the component being tested
	component bubbly.Component

	// bindings maps keys to their key binding configurations
	bindings map[string][]bubbly.KeyBinding

	// conflicts tracks detected key binding conflicts
	conflicts []string
}

// NewKeyBindingsTester creates a new KeyBindingsTester for testing key bindings.
//
// Parameters:
//   - comp: The component to test
//
// Returns:
//   - *KeyBindingsTester: A new tester instance
//
// Example:
//
//	comp, _ := bubbly.NewComponent("Counter").
//		WithKeyBinding(" ", "increment", "Increment").
//		Build()
//
//	tester := testutil.NewKeyBindingsTester(comp)
func NewKeyBindingsTester(comp bubbly.Component) *KeyBindingsTester {
	// Get bindings from component
	bindings := comp.KeyBindings()

	return &KeyBindingsTester{
		component: comp,
		bindings:  bindings,
		conflicts: []string{},
	}
}

// SimulateKeyPress simulates pressing a keyboard key and returns any command generated.
//
// This method creates a Bubbletea key message for the specified key and passes it
// to the component's Update method, simulating what would happen when the user
// presses that key. This allows testing that key bindings trigger the correct events.
//
// Parameters:
//   - key: The key to simulate (e.g., " ", "enter", "ctrl+c")
//
// Returns:
//   - tea.Cmd: Any command generated by the key press (may be nil)
//
// Example:
//
//	tester := testutil.NewKeyBindingsTester(comp)
//	cmd := tester.SimulateKeyPress(" ")  // Simulate space key
//	assert.NotNil(t, cmd)
func (kbt *KeyBindingsTester) SimulateKeyPress(key string) tea.Cmd {
	// Create appropriate key message based on the key string
	var msg tea.Msg

	switch key {
	case " ":
		msg = tea.KeyMsg{Type: tea.KeySpace}
	case "enter":
		msg = tea.KeyMsg{Type: tea.KeyEnter}
	case "esc":
		msg = tea.KeyMsg{Type: tea.KeyEsc}
	case "up":
		msg = tea.KeyMsg{Type: tea.KeyUp}
	case "down":
		msg = tea.KeyMsg{Type: tea.KeyDown}
	case "left":
		msg = tea.KeyMsg{Type: tea.KeyLeft}
	case "right":
		msg = tea.KeyMsg{Type: tea.KeyRight}
	case "tab":
		msg = tea.KeyMsg{Type: tea.KeyTab}
	case "backspace":
		msg = tea.KeyMsg{Type: tea.KeyBackspace}
	case "delete":
		msg = tea.KeyMsg{Type: tea.KeyDelete}
	default:
		// For other keys (including ctrl+, alt+, and regular characters)
		// Use KeyRunes type
		if len(key) == 1 {
			msg = tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{rune(key[0])}}
		} else {
			// For complex keys like "ctrl+c", create a message with the string
			msg = tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(key)}
		}
	}

	// Send message to component
	_, cmd := kbt.component.Update(msg)

	return cmd
}

// AssertHelpText asserts that the component's help text matches the expected value.
//
// This method retrieves the component's auto-generated help text and compares it
// to the expected value. Help text is generated from key binding descriptions in
// the format: "key: description • key: description"
//
// Parameters:
//   - t: The testing.T instance (or mock)
//   - expected: The expected help text
//
// Example:
//
//	tester.AssertHelpText(t, " : Increment • r: Reset")
func (kbt *KeyBindingsTester) AssertHelpText(t testingT, expected string) {
	t.Helper()

	// Get help text from component
	actual := kbt.component.HelpText()

	// Compare
	if actual != expected {
		t.Errorf("expected help text %q, got %q", expected, actual)
	}
}

// DetectConflicts detects key binding conflicts (multiple bindings for the same key).
//
// This method analyzes the component's key bindings and identifies any keys that
// have multiple bindings registered. While conditional bindings (with Condition functions)
// can legitimately share keys for mode-based input, unconditional conflicts may
// indicate configuration errors.
//
// Returns:
//   - []string: List of keys that have conflicts
//
// Example:
//
//	conflicts := tester.DetectConflicts()
//	if len(conflicts) > 0 {
//		t.Errorf("Found key binding conflicts: %v", conflicts)
//	}
func (kbt *KeyBindingsTester) DetectConflicts() []string {
	conflicts := []string{}

	// Check each key for multiple bindings
	for key, bindingList := range kbt.bindings {
		if len(bindingList) > 1 {
			// This key has multiple bindings - potential conflict
			conflicts = append(conflicts, key)
		}
	}

	// Store conflicts for later inspection
	kbt.conflicts = conflicts

	return conflicts
}
