package testutil

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"testing"

	"github.com/newbpydev/bubblyui/pkg/bubbly"
)

// MatchSnapshot compares the actual content with a saved snapshot using automatic naming.
//
// The snapshot name is automatically generated from the test name with "_default" suffix.
// For example, in a test named "TestMyFeature", the snapshot will be named
// "TestMyFeature_default.snap".
//
// On the first run, this creates a new snapshot file. On subsequent runs, it compares
// the actual content with the saved snapshot and fails the test if they don't match.
//
// To update snapshots when they change intentionally, set the UPDATE_SNAPS environment
// variable to "true" or "1" before running tests.
//
// Parameters:
//   - t: The testing interface (typically *testing.T)
//   - actual: The actual content to snapshot
//
// Example:
//
//	func TestMyComponent(t *testing.T) {
//	    output := component.View()
//	    testutil.MatchSnapshot(t, output)
//	}
func MatchSnapshot(t *testing.T, actual string) {
	t.Helper()

	// Get test directory from testing.T
	testDir := getTestDir(t)

	// Generate snapshot name from test name
	name := sanitizeTestName(t.Name()) + "_default"

	// Create snapshot manager
	sm := NewSnapshotManager(testDir, UpdateSnapshots(t))

	// Match snapshot
	sm.Match(t, name, actual)
}

// MatchNamedSnapshot compares the actual content with a saved snapshot using a custom name.
//
// This allows you to create multiple snapshots within the same test with different names.
// The snapshot name is generated by combining the test name with the provided custom name.
//
// For example, in a test named "TestMyFeature" with name "initial_state", the snapshot
// will be named "TestMyFeature_initial_state.snap".
//
// Parameters:
//   - t: The testing interface (typically *testing.T)
//   - name: Custom name for the snapshot (will be combined with test name)
//   - actual: The actual content to snapshot
//
// Example:
//
//	func TestCounter(t *testing.T) {
//	    testutil.MatchNamedSnapshot(t, "initial", counter.View())
//	    counter.Increment()
//	    testutil.MatchNamedSnapshot(t, "after_increment", counter.View())
//	}
func MatchNamedSnapshot(t *testing.T, name, actual string) {
	t.Helper()

	// Get test directory from testing.T
	testDir := getTestDir(t)

	// Generate snapshot name from test name and custom name
	fullName := sanitizeTestName(t.Name()) + "_" + name

	// Create snapshot manager
	sm := NewSnapshotManager(testDir, UpdateSnapshots(t))

	// Match snapshot
	sm.Match(t, fullName, actual)
}

// MatchComponentSnapshot compares a component's rendered output with a saved snapshot.
//
// This is a convenience function that calls component.View() and matches the output
// against a snapshot. It uses automatic naming like MatchSnapshot.
//
// Parameters:
//   - t: The testing interface (typically *testing.T)
//   - component: The component to snapshot (must implement bubbly.Component)
//
// Example:
//
//	func TestButton(t *testing.T) {
//	    button := components.Button(components.ButtonProps{
//	        Label: "Click Me",
//	    })
//	    button.Init()
//	    testutil.MatchComponentSnapshot(t, button)
//	}
func MatchComponentSnapshot(t *testing.T, component bubbly.Component) {
	t.Helper()

	// Get component's rendered output
	output := component.View()

	// Match using default snapshot
	MatchSnapshot(t, output)
}

// UpdateSnapshots checks if snapshot update mode is enabled.
//
// This function checks the UPDATE_SNAPS environment variable to determine
// if snapshots should be updated instead of compared. The following values
// are considered "true": "true", "1", "yes", "y" (case-insensitive).
//
// Returns:
//   - bool: true if snapshots should be updated, false otherwise
//
// Example:
//
//	// Run tests with snapshot update:
//	// UPDATE_SNAPS=true go test ./...
//	//
//	// In test code:
//	if testutil.UpdateSnapshots(t) {
//	    t.Log("Running in snapshot update mode")
//	}
func UpdateSnapshots(t *testing.T) bool {
	t.Helper()

	value := os.Getenv("UPDATE_SNAPS")
	if value == "" {
		return false
	}

	// Normalize to lowercase for comparison
	value = strings.ToLower(strings.TrimSpace(value))

	// Check for truthy values
	return value == "true" || value == "1" || value == "yes" || value == "y"
}

// testDirCache stores the temp directory for each test to ensure consistency.
// This prevents creating multiple temp directories for the same test.
var testDirCache = make(map[string]string)
var testDirMu sync.Mutex

// getTestDir returns the directory where test files are located.
// This is used to determine where to store snapshot files.
// It caches the directory per test to ensure all snapshot operations
// in the same test use the same directory.
func getTestDir(t *testing.T) string {
	t.Helper()

	testDirMu.Lock()
	defer testDirMu.Unlock()

	// Use test name as cache key
	testName := t.Name()

	// Check if we already have a directory for this test
	if dir, ok := testDirCache[testName]; ok {
		return dir
	}

	// Create new temp directory
	dir := t.TempDir()

	// Cache it
	testDirCache[testName] = dir

	// Clean up cache when test completes
	t.Cleanup(func() {
		testDirMu.Lock()
		defer testDirMu.Unlock()
		delete(testDirCache, testName)
	})

	return dir
}

// sanitizeTestName converts a test name to a valid filename.
// It replaces slashes and spaces with underscores.
func sanitizeTestName(name string) string {
	// Replace path separators (from subtests) with underscores
	name = strings.ReplaceAll(name, "/", "_")

	// Replace spaces with underscores
	name = strings.ReplaceAll(name, " ", "_")

	return name
}

// GetSnapshotManager returns a snapshot manager for the current test.
//
// This is a convenience function that creates a SnapshotManager with
// the appropriate test directory and update mode settings.
//
// Parameters:
//   - t: The testing interface (typically *testing.T)
//
// Returns:
//   - *SnapshotManager: A snapshot manager for the current test
//
// Example:
//
//	func TestCustomSnapshot(t *testing.T) {
//	    sm := testutil.GetSnapshotManager(t)
//	    sm.Match(t, "custom_name", actualOutput)
//	}
func GetSnapshotManager(t *testing.T) *SnapshotManager {
	t.Helper()

	testDir := getTestDir(t)
	update := UpdateSnapshots(t)

	return NewSnapshotManager(testDir, update)
}

// MatchSnapshotWithOptions matches a snapshot with custom options.
//
// This provides more control over snapshot matching by allowing you to
// specify a custom directory and update mode.
//
// Parameters:
//   - t: The testing interface (typically *testing.T)
//   - name: Name for the snapshot
//   - actual: The actual content to snapshot
//   - dir: Custom directory for snapshots (empty string uses default)
//   - update: Whether to update snapshots on mismatch
//
// Example:
//
//	func TestWithCustomDir(t *testing.T) {
//	    testutil.MatchSnapshotWithOptions(t, "my_snap", output, "/custom/dir", false)
//	}
func MatchSnapshotWithOptions(t *testing.T, name, actual, dir string, update bool) {
	t.Helper()

	if dir == "" {
		dir = getTestDir(t)
	}

	sm := NewSnapshotManager(dir, update)
	sm.Match(t, name, actual)
}

// SnapshotExists checks if a snapshot file exists for the given name.
//
// This can be useful for conditional snapshot creation or verification.
//
// Parameters:
//   - t: The testing interface (typically *testing.T)
//   - name: Name of the snapshot to check
//
// Returns:
//   - bool: true if the snapshot file exists, false otherwise
//
// Example:
//
//	func TestConditionalSnapshot(t *testing.T) {
//	    if !testutil.SnapshotExists(t, "my_snapshot") {
//	        t.Log("Creating new snapshot")
//	    }
//	    testutil.MatchNamedSnapshot(t, "my_snapshot", output)
//	}
func SnapshotExists(t *testing.T, name string) bool {
	t.Helper()

	testDir := getTestDir(t)
	sm := NewSnapshotManager(testDir, false)
	snapFile := sm.getSnapshotFile(name)

	_, err := os.Stat(snapFile)
	return err == nil
}

// GetSnapshotPath returns the full path to a snapshot file.
//
// This is useful for debugging or manual snapshot inspection.
//
// Parameters:
//   - t: The testing interface (typically *testing.T)
//   - name: Name of the snapshot
//
// Returns:
//   - string: Full path to the snapshot file
//
// Example:
//
//	func TestSnapshotPath(t *testing.T) {
//	    path := testutil.GetSnapshotPath(t, "my_snapshot")
//	    t.Logf("Snapshot will be saved to: %s", path)
//	}
func GetSnapshotPath(t *testing.T, name string) string {
	t.Helper()

	testDir := getTestDir(t)
	return filepath.Join(testDir, "__snapshots__", name+".snap")
}

// ReadSnapshot reads the content of an existing snapshot file.
//
// This can be useful for custom snapshot verification or debugging.
//
// Parameters:
//   - t: The testing interface (typically *testing.T)
//   - name: Name of the snapshot to read
//
// Returns:
//   - string: Content of the snapshot file
//   - error: Error if the file doesn't exist or can't be read
//
// Example:
//
//	func TestReadSnapshot(t *testing.T) {
//	    content, err := testutil.ReadSnapshot(t, "my_snapshot")
//	    if err != nil {
//	        t.Fatalf("Failed to read snapshot: %v", err)
//	    }
//	    t.Logf("Snapshot content: %s", content)
//	}
func ReadSnapshot(t *testing.T, name string) (string, error) {
	t.Helper()

	snapPath := GetSnapshotPath(t, name)
	content, err := os.ReadFile(snapPath)
	if err != nil {
		return "", fmt.Errorf("failed to read snapshot %q: %w", name, err)
	}

	return string(content), nil
}
