package testutil

import (
	tea "github.com/charmbracelet/bubbletea"

	"github.com/newbpydev/bubblyui/pkg/bubbly"
)

// CommandQueueInspector provides inspection utilities for testing command queues
// in the automatic reactive bridge system.
//
// This inspector wraps a CommandQueue and provides methods to examine pending
// commands for testing purposes. It's designed to help verify that commands are
// generated correctly when reactive state changes occur.
//
// Thread Safety:
//
// All methods are thread-safe as they delegate to the underlying CommandQueue
// which provides synchronization via mutex.
//
// Example usage:
//
//	queue := bubbly.NewCommandQueue()
//	inspector := testutil.NewCommandQueueInspector(queue)
//
//	// Trigger state change that generates commands
//	ref.Set(42)
//
//	// Verify command was enqueued
//	inspector.AssertEnqueued(t, 1)
//
//	// Inspect the command
//	cmd := inspector.Peek()
//	assert.NotNil(t, cmd)
type CommandQueueInspector struct {
	queue *bubbly.CommandQueue
}

// NewCommandQueueInspector creates a new command queue inspector.
//
// The inspector wraps the given CommandQueue and provides testing utilities
// for examining pending commands. The queue parameter can be nil, in which
// case all methods return safe defaults (0 length, nil commands, no-op operations).
//
// Parameters:
//   - queue: The CommandQueue to inspect (can be nil)
//
// Returns:
//   - *CommandQueueInspector: Ready to use for testing
//
// Example:
//
//	queue := bubbly.NewCommandQueue()
//	inspector := NewCommandQueueInspector(queue)
//	assert.Equal(t, 0, inspector.Len())
func NewCommandQueueInspector(queue *bubbly.CommandQueue) *CommandQueueInspector {
	return &CommandQueueInspector{
		queue: queue,
	}
}

// Len returns the number of commands currently in the queue.
//
// This method provides a quick way to check how many commands are pending
// without modifying the queue. It's useful for verifying that the expected
// number of commands were generated by reactive state changes.
//
// Returns:
//   - int: Number of pending commands (0 if queue is nil or empty)
//
// Thread Safety:
//
// This method is thread-safe and delegates to CommandQueue.Len() which
// provides synchronization.
//
// Example:
//
//	inspector := NewCommandQueueInspector(queue)
//	count := inspector.Len()
//	assert.Equal(t, 2, count, "expected 2 commands")
func (cqi *CommandQueueInspector) Len() int {
	if cqi.queue == nil {
		return 0
	}
	return cqi.queue.Len()
}

// Peek returns the first command in the queue without removing it.
//
// This method allows you to inspect the next command that would be executed
// without modifying the queue. It's useful for verifying command properties
// or executing the command to inspect its message.
//
// Returns:
//   - tea.Cmd: The first command in the queue
//   - nil if queue is nil or empty
//
// Thread Safety:
//
// This method is thread-safe and delegates to CommandQueue.Peek() which
// provides synchronization.
//
// Example:
//
//	cmd := inspector.Peek()
//	if cmd != nil {
//	    msg := cmd()
//	    stateMsg, ok := msg.(bubbly.StateChangedMsg)
//	    assert.True(t, ok)
//	}
func (cqi *CommandQueueInspector) Peek() tea.Cmd {
	if cqi.queue == nil {
		return nil
	}

	cmds := cqi.queue.Peek()
	if len(cmds) == 0 {
		return nil
	}

	return cmds[0]
}

// GetAll returns all commands currently in the queue without removing them.
//
// This method returns a snapshot of all pending commands. The returned slice
// is a copy, so modifications to it do not affect the queue. This is useful
// for inspecting multiple commands or verifying command order.
//
// Returns:
//   - []tea.Cmd: All commands in the queue
//   - nil if queue is nil or empty
//
// Thread Safety:
//
// This method is thread-safe and delegates to CommandQueue.Peek() which
// provides synchronization and returns a copy of the command slice.
//
// Example:
//
//	cmds := inspector.GetAll()
//	assert.Equal(t, 3, len(cmds), "expected 3 commands")
//	for i, cmd := range cmds {
//	    msg := cmd()
//	    // Verify each command's message
//	}
func (cqi *CommandQueueInspector) GetAll() []tea.Cmd {
	if cqi.queue == nil {
		return nil
	}
	return cqi.queue.Peek()
}

// Clear removes all commands from the queue.
//
// This method is useful for resetting the queue state between test cases
// or cleaning up after testing. It's safe to call on an empty queue or
// nil queue (no-op).
//
// Thread Safety:
//
// This method is thread-safe and delegates to CommandQueue.Clear() which
// provides synchronization.
//
// Example:
//
//	// Setup test
//	inspector.Clear()
//	assert.Equal(t, 0, inspector.Len())
//
//	// Run test that generates commands
//	ref.Set(42)
//	assert.Equal(t, 1, inspector.Len())
func (cqi *CommandQueueInspector) Clear() {
	if cqi.queue == nil {
		return
	}
	cqi.queue.Clear()
}

// AssertEnqueued asserts that the queue contains exactly the expected number
// of commands.
//
// This is a convenience assertion method that checks the queue length and
// reports a clear error message if the count doesn't match. It uses t.Helper()
// to ensure the error is reported at the correct line in the test.
//
// Parameters:
//   - t: The testing.T instance (or testingT interface)
//   - count: The expected number of commands
//
// Thread Safety:
//
// This method is thread-safe as it delegates to Len() which is thread-safe.
//
// Example:
//
//	// Verify single command generated
//	ref.Set(42)
//	inspector.AssertEnqueued(t, 1)
//
//	// Verify multiple commands
//	ref1.Set(1)
//	ref2.Set(2)
//	ref3.Set(3)
//	inspector.AssertEnqueued(t, 3)
func (cqi *CommandQueueInspector) AssertEnqueued(t testingT, count int) {
	t.Helper()

	actual := cqi.Len()
	if actual != count {
		t.Errorf("command queue: expected %d commands, got %d", count, actual)
	}
}
