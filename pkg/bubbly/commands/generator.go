// Package commands provides automatic command generation for reactive state changes.
//
// This package implements the automatic reactive bridge that eliminates manual
// bridge code between BubblyUI components and Bubbletea's message loop. When a
// Ref.Set() is called, the framework automatically generates a Bubbletea command
// that triggers a UI update.
//
// Core Types:
//   - CommandGenerator: Interface for generating commands from state changes
//   - StateChangedMsg: Message type for state change notifications
//
// Example:
//
//	// Create a command generator
//	gen := &DefaultCommandGenerator{}
//
//	// Generate command from state change
//	cmd := gen.Generate("counter-1", "count", 0, 1)
//
//	// Command returns StateChangedMsg when executed
//	msg := cmd() // StateChangedMsg{ComponentID: "counter-1", RefID: "count", ...}
package commands

import (
	"time"

	tea "github.com/charmbracelet/bubbletea"
)

// CommandGenerator creates Bubbletea commands from reactive state changes.
//
// This interface is the foundation of the automatic reactive bridge. When a
// Ref.Set() is called, the CommandGenerator creates a tea.Cmd that will trigger
// the component's Update() cycle, causing a re-render without manual Emit() calls.
//
// The generator receives the component ID, ref ID, old value, and new value,
// and returns a tea.Cmd that produces a StateChangedMsg when executed.
//
// Implementations:
//   - DefaultCommandGenerator: Standard implementation for most use cases
//   - Custom generators: Can be provided for specialized command generation
//
// Example:
//
//	type MyGenerator struct{}
//
//	func (g *MyGenerator) Generate(componentID, refID string, oldValue, newValue interface{}) tea.Cmd {
//	    return func() tea.Msg {
//	        return StateChangedMsg{
//	            ComponentID: componentID,
//	            RefID:       refID,
//	            OldValue:    oldValue,
//	            NewValue:    newValue,
//	            Timestamp:   time.Now(),
//	        }
//	    }
//	}
type CommandGenerator interface {
	// Generate creates a tea.Cmd from a state change.
	//
	// Parameters:
	//   - componentID: Unique identifier of the component owning the ref
	//   - refID: Unique identifier of the ref that changed
	//   - oldValue: Previous value before the change
	//   - newValue: New value after the change
	//
	// Returns:
	//   - tea.Cmd that produces a StateChangedMsg when executed
	//
	// The returned command is enqueued in the component's command queue and
	// returned from the component's Update() method, triggering Bubbletea's
	// message loop to process the state change.
	Generate(componentID, refID string, oldValue, newValue interface{}) tea.Cmd
}

// StateChangedMsg signals that a reactive state change has occurred.
//
// This message is generated by CommandGenerator when a Ref.Set() is called
// in automatic mode. It flows through Bubbletea's message loop and triggers
// the component's Update() cycle, causing lifecycle hooks (onUpdated) to
// execute and the View() to re-render.
//
// Fields:
//   - ComponentID: Unique identifier of the component owning the ref
//   - RefID: Unique identifier of the ref that changed
//   - OldValue: Previous value before the change (for debugging/logging)
//   - NewValue: New value after the change (for debugging/logging)
//   - Timestamp: When the state change occurred
//
// Note: The actual state value is already updated synchronously by Ref.Set().
// This message exists to trigger the asynchronous UI update cycle.
//
// Example:
//
//	func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
//	    switch msg := msg.(type) {
//	    case commands.StateChangedMsg:
//	        if msg.ComponentID == m.component.ID() {
//	            // State already updated, execute hooks
//	            m.component.ExecuteUpdatedHooks()
//	        }
//	    }
//	    return m, nil
//	}
type StateChangedMsg struct {
	// ComponentID identifies which component's state changed
	ComponentID string

	// RefID identifies which ref within the component changed
	RefID string

	// OldValue is the previous value (for debugging/logging)
	// The actual ref value is already updated synchronously
	OldValue interface{}

	// NewValue is the new value (for debugging/logging)
	// The actual ref value is already updated synchronously
	NewValue interface{}

	// Timestamp records when the state change occurred
	Timestamp time.Time
}
