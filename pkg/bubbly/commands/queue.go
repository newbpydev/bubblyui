package commands

import (
	"sync"

	tea "github.com/charmbracelet/bubbletea"
)

// CommandQueue is a thread-safe queue for pending Bubbletea commands.
//
// This queue stores commands generated by CommandRef.Set() operations and
// provides them to the component's Update() method for batching and execution.
//
// Thread Safety:
//
// All methods are thread-safe and can be called concurrently from multiple
// goroutines. A mutex protects the internal command slice.
//
// Example:
//
//	queue := NewCommandQueue()
//	queue.Enqueue(cmd1)
//	queue.Enqueue(cmd2)
//
//	// In component's Update():
//	cmds := queue.DrainAll()  // Returns [cmd1, cmd2] and clears queue
type CommandQueue struct {
	commands []tea.Cmd
	mu       sync.Mutex
}

// NewCommandQueue creates a new empty command queue.
func NewCommandQueue() *CommandQueue {
	return &CommandQueue{
		commands: make([]tea.Cmd, 0, 8), // Pre-allocate for common case
	}
}

// Enqueue adds a command to the queue.
//
// This method is thread-safe and can be called concurrently.
// Nil commands are ignored.
//
// Example:
//
//	queue.Enqueue(cmd)
func (cq *CommandQueue) Enqueue(cmd tea.Cmd) {
	if cmd == nil {
		return
	}

	cq.mu.Lock()
	defer cq.mu.Unlock()
	cq.commands = append(cq.commands, cmd)
}

// DrainAll returns all queued commands and clears the queue.
//
// This method is thread-safe and can be called concurrently.
// Returns an empty slice if the queue is empty.
//
// Example:
//
//	cmds := queue.DrainAll()
//	for _, cmd := range cmds {
//	    // Execute command
//	}
func (cq *CommandQueue) DrainAll() []tea.Cmd {
	cq.mu.Lock()
	defer cq.mu.Unlock()

	if len(cq.commands) == 0 {
		return nil
	}

	cmds := cq.commands
	cq.commands = make([]tea.Cmd, 0, 8)
	return cmds
}

// Len returns the number of commands currently in the queue.
//
// This method is thread-safe and can be called concurrently.
//
// Example:
//
//	count := queue.Len()
func (cq *CommandQueue) Len() int {
	cq.mu.Lock()
	defer cq.mu.Unlock()
	return len(cq.commands)
}

// Clear removes all commands from the queue.
//
// This method is thread-safe and can be called concurrently.
//
// Example:
//
//	queue.Clear()
func (cq *CommandQueue) Clear() {
	cq.mu.Lock()
	defer cq.mu.Unlock()
	cq.commands = make([]tea.Cmd, 0, 8)
}
